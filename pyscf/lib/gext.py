"""Module for performing Grassmann extrapolations."""

import warnings
import numpy as np

def _grassmann_log(c: np.ndarray, c0: np.ndarray) -> np.ndarray:
    """Grassmann logarithm."""
    psi, s, rt = np.linalg.svd(c.T @ c0, full_matrices=False)
    cstar = c @ psi @ rt
    l = (np.identity(c.shape[0]) - c0 @ c0.T) @ cstar
    u, s, vt = np.linalg.svd(l, full_matrices=False)
    arcsin_s = np.diag(np.arcsin(s))
    return u @ arcsin_s @ vt

def _grassmann_exp(gamma: np.ndarray, c0: np.ndarray) -> np.ndarray:
    """Grassmann exponential."""
    q, s, vt = np.linalg.svd(gamma, full_matrices=False)
    sin_s = np.diag(np.sin(s))
    cos_s = np.diag(np.cos(s))
    return c0 @ vt.T @ cos_s @ vt + q @ sin_s @ vt

class Extrapolator:

    """Class for performing Grassmann extrapolations. On initialization
    it requires the number of electrons. New data points can be
    added by calling the `load` method, and guesses are generated by
    calling the `guess` method."""

    def __init__(self, nelectrons):
        self.max_npoints = 50
        self.nelectrons = nelectrons
        self.descriptors = []
        self.coefficients = []
        self.overlaps = []
        self.fit = Fitting(regularization=1e-4)
        self.npoints = 0

    def load_(self, descriptor: np.ndarray, coeff: np.ndarray,
            overlap: np.ndarray):
        """Load a new data point in the extrapolator."""
        try:
            # Crop the coefficient matrix up to the number of electron
            # pairs, then apply S^1/2
            coeff = self._crop_coeff(coeff)
            coeff = self._normalize(coeff, overlap)

            self.descriptors.append(descriptor.flatten())

            # if the number of data points exceeds the maximum allowed
            # the oldest data point is discarded
            if self.npoints >= self.max_npoints:
                self.coefficients.pop(0)
                self.overlaps.pop(0)
            else:
                self.npoints += 1

            self.coefficients.append(coeff)
            self.overlaps.append(overlap)

        except Exception as e:
            warnings.warn(f"Error in Extrapolator.load_: {e}")

    def guess(self, descriptor: np.ndarray, overlap: np.ndarray):
        """Get a new coefficient matrix to be used as a guess."""
        #try:
        if not self._ready_to_guess():
            return None

        # map the previous coefficient matrices to a vector space
        gammas = []
        for coeff in self.coefficients:
            gammas.append(self._grassmann_log(coeff))

        # train the model and then evaluate it at the new descriptor
        self.fit.train(self.descriptors, gammas)
        gamma = self.fit.extrapolate(descriptor)

        # transform the guess vector in a gues coefficient matrix and
        # remove the normalization by S^1/2
        c_guess = self._grassmann_exp(gamma)
        return self._unnormalize(c_guess, overlap)
        #except Exception as e:
        #    warnings.warn("Error in Extrapolator.guess, swiching" +
        #        f"to a normal guess: {e}")
        #    return None

    def _ready_to_guess(self):
        """Check if enough data points have been loaded."""
        if self.npoints > 1:
            return True
        return False

    def _crop_coeff(self, coeff):
        """Crop the coefficient matrix to remove the virtual orbitals."""
        return coeff[:, :self.nelectrons//2]

    def _normalize(self, coeff, overlap):
        """Normalize the coefficients such that C.T * C = 1, D * D = D."""
        return self._sqrt_overlap(overlap).dot(coeff)

    def _unnormalize(self, coeff, overlap):
        """Remove the normalization from the coefficients."""
        return self._inverse_sqrt_overlap(overlap).dot(coeff)

    def _get_tangent(self):
        """Return the coefficient matrix corresponding to the tangent
        point."""
        return self.coefficients[-1]

    def _grassmann_log(self, coeff):
        """Map from the manifold to the tangent plane."""
        tangent = self._get_tangent()
        return _grassmann_log(coeff, tangent)

    def _grassmann_exp(self, gamma):
        """Map from the tangent plane to the manifold."""
        tangent = self._get_tangent()
        return _grassmann_exp(gamma, tangent)

    def _sqrt_overlap(self, overlap):
        """Compute the square root of the overlap matrix."""
        q, s, vt = np.linalg.svd(overlap, full_matrices=False)
        return q @ np.diag(np.sqrt(s)) @ vt

    def _inverse_sqrt_overlap(self, overlap):
        """Compute the square root of the overlap matrix."""
        q, s, vt = np.linalg.svd(overlap, full_matrices=False)
        return q @ np.diag(1.0/np.sqrt(s)) @ vt

class Fitting:

    """Simple least square minimization fitting."""

    def __init__(self, regularization=1e-4):
        self.regularization = regularization
        self.matrix = None
        self.ref = None
        self.gammas = None

    def train(self, vectors, gammas):
        """Given a set of vectors and gammas prepare the object for
        doing an extrapolation."""

        if len(vectors) == 1:
            raise ValueError("The fitting does not work for one vector")

        self.ref = vectors[-1]
        self.gammas = gammas[:-1]

        diff_vectors = []
        for i in range(len(vectors) - 1):
            diff_vectors.append(vectors[i] - self.ref)
        d = np.array(diff_vectors).T

        # compute the Moore-Penrose pseudo inverse of the descriptors
        a = d.T @ d
        if self.regularization > 0.0:
            a += np.identity(a.shape[0])*self.regularization**2
        self.matrix = np.linalg.inv(a) @ d.T

    def extrapolate(self, descriptor):
        """Given a new descriptor extrapolate the corresponding gamma."""

        if self.matrix is None:
            raise ValueError("The model is not trained.")

        coefficients = self.matrix @ (descriptor.flatten() - self.ref)
        result = np.zeros(self.gammas[0].shape, dtype=np.float64)
        for coeff, gamma in zip(coefficients, self.gammas):
            result += gamma*coeff
        return result

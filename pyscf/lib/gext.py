"""Module for performing Grassmann extrapolations."""

import numpy as np

def _grassmann_log(c: np.ndarray, c0: np.ndarray) -> np.ndarray:
    """Grassmann logarithm."""
    psi, s, rt = np.linalg.svd(c.T @ c0, full_matrices=False)
    cstar = c @ psi @ rt
    l = (np.identity(c.shape[0]) - c0 @ c0.T) @ cstar
    u, s, vt = np.linalg.svd(l, full_matrices=False)
    arcsin_s = np.diag(np.arcsin(s))
    return u @ arcsin_s @ vt

def _grassmann_exp(gamma: np.ndarray, c0: np.ndarray) -> np.ndarray:
    """Grassmann exponential."""
    q, s, vt = np.linalg.svd(gamma, full_matrices=False)
    sin_s = np.diag(np.sin(s))
    cos_s = np.diag(np.cos(s))
    return c0 @ vt.T @ cos_s @ vt + q @ sin_s @ vt

class Extrapolator:

    """Class for performing Grassmann extrapolations. On initialization
    it requires the number of electrons. New data points can be
    added by calling the `load` method, and guesses are generated by
    calling the `guess` method."""

    def __init__(self, nelectrons):
        self.nelectrons = nelectrons
        self.descriptors = []
        self.coefficients = []
        self.overlaps = []
        self.fit = Fitting(regularization=1e-4)
        self.npoints = 0

    def load_(self, descriptor: np.ndarray, coeff: np.ndarray,
            overlap: np.ndarray):
        """Load a new data point in the extrapolator."""

        # Crop the coefficient matrix up to the number of electron
        # pairs, then apply S^1/2
        coeff = self._crop_coeff(coeff)
        coeff = self._normalize(coeff, overlap)

        self.descriptors.append(descriptor.flatten())
        self.coefficients.append(coeff)
        self.overlaps.append(overlap)

        self.npoints += 1


    def guess(self, descriptor: np.ndarray, overlap: np.ndarray):
        """Get a new coefficient matrix to be used as a guess."""

        if not self._ready_to_guess():
            return None

        # get the fitting coefficients that best approximate the new
        # descriptor
        fit_coefficients = self.fit.fit(self.descriptors, descriptor.flatten())

        # map the previous coefficient matrices to a vector space
        gammas = []
        for coeff in self.coefficients:
            gammas.append(self._grassmann_log(coeff))

        # use the fitting coefficients and the vectors to build a
        # guess vector
        gamma = self.fit.linear_combination(gammas, fit_coefficients)

        # transform the guess vector in a gues coefficient matrix and
        # remove the normalization by S^1/2
        c_guess = self._grassmann_exp(gamma)
        return self._unnormalize(c_guess, overlap)

    def _ready_to_guess(self):
        if self.npoints > 1:
            return True
        return False

    def _crop_coeff(self, coeff):
        """Crop the coefficient matrix to remove the virtual orbitals."""
        return coeff[:, :self.nelectrons//2]

    def _normalize(self, coeff, overlap):
        """Normalize the coefficients such that C.T * C = 1, D * D = D."""
        return self._sqrt_overlap(overlap).dot(coeff)

    def _unnormalize(self, coeff, overlap):
        """Remove the normalization from the coefficients."""
        return self._inverse_sqrt_overlap(overlap).dot(coeff)

    def _get_tangent(self):
        """Return the coefficient matrix corresponding to the tangent
        point."""
        return self.coefficients[-1]

    def _grassmann_log(self, coeff):
        """Map from the manifold to the tangent plane."""
        tangent = self._get_tangent()
        return _grassmann_log(coeff, tangent)

    def _grassmann_exp(self, gamma):
        """Map from the tangent plane to the manifold."""
        tangent = self._get_tangent()
        return _grassmann_exp(gamma, tangent)

    def _sqrt_overlap(self, overlap):
        """Compute the square root of the overlap matrix."""
        q, s, vt = np.linalg.svd(overlap, full_matrices=False)
        return q @ np.diag(np.sqrt(s)) @ vt

    def _inverse_sqrt_overlap(self, overlap):
        """Compute the square root of the overlap matrix."""
        q, s, vt = np.linalg.svd(overlap, full_matrices=False)
        return q @ np.diag(1.0/np.sqrt(s)) @ vt

class Fitting:

    """Simple least square minimization fitting."""

    def __init__(self, regularization=1e-4):
        self.regularization = regularization

    def fit(self, vectors, target):
        """Given a set of vectors and a target return the fitting
        coefficients."""

        if len(vectors) == 1:
            raise ValueError("The fitting does not work for one vector")

        target -= vectors[-1]

        diff_vectors = []
        for i in range(1, len(vectors)):
            diff_vectors.append(vectors[i-1] - vectors[-1])

        matrix = np.array(diff_vectors).T
        a = matrix.T @ matrix
        b = matrix.T @ target
        if self.regularization > 0.0:
            a += np.identity(len(b))*self.regularization**2
        coefficients = np.linalg.solve(a, b)

        return np.concatenate((coefficients, [1.0 - np.sum(coefficients)]))

    def linear_combination(self, vectors, coefficients):
        """Given a set of vectors (or matrices) and the corresponding
        coefficients, build their linear combination."""
        result = np.zeros(vectors[0].shape, dtype=np.float64)
        for coeff, vector in zip(coefficients, vectors):
            result += vector*coeff
        return result
